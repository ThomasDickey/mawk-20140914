MAWK(1)                                                                MAWK(1)



NNAAMMEE
       mawk - pattern scanning and text processing language

SSYYNNOOPPSSIISS
       mmaawwkk  [-WW  _o_p_t_i_o_n]  [-FF _v_a_l_u_e] [-vv _v_a_r_=_v_a_l_u_e] [--] 'program text' [file
       ...]
       mmaawwkk [-WW _o_p_t_i_o_n] [-FF _v_a_l_u_e] [-vv _v_a_r_=_v_a_l_u_e] [-ff _p_r_o_g_r_a_m_-_f_i_l_e] [--] [file
       ...]

DDEESSCCRRIIPPTTIIOONN
       mmaawwkk  is an interpreter for the AWK Programming Language.  The AWK lan-
       guage is useful for manipulation of data files, text retrieval and pro-
       cessing,  and  for prototyping and experimenting with algorithms.  mmaawwkk
       is a _n_e_w _a_w_k meaning it implements the AWK language as defined in  Aho,
       Kernighan  and Weinberger, _T_h_e _A_W_K _P_r_o_g_r_a_m_m_i_n_g _L_a_n_g_u_a_g_e_, Addison-Wesley
       Publishing, 1988.  (Hereafter referred to as the AWK book.)  mmaawwkk  con-
       forms  to  the Posix 1003.2 (draft 11.3) definition of the AWK language
       which contains a few features not described in the AWK book,  and  mmaawwkk
       provides a small number of extensions.

       An  AWK  program  is  a sequence of _p_a_t_t_e_r_n _{_a_c_t_i_o_n_} pairs and function
       definitions.  Short programs are entered on the  command  line  usually
       enclosed  in ' ' to avoid shell interpretation.  Longer programs can be
       read in from a file with the -f option.  Data  input is read  from  the
       list  of files on the command line or from standard input when the list
       is empty.  The input is broken into records as determined by the record
       separator  variable,  RRSS.  Initially, RRSS = "\n" and records are synony-
       mous with lines.  Each record is compared against each _p_a_t_t_e_r_n  and  if
       it matches, the program text for _{_a_c_t_i_o_n_} is executed.

OOPPTTIIOONNSS
       -FF _v_a_l_u_e       sets the field separator, FFSS, to _v_a_l_u_e.

       -ff _f_i_l_e        Program  text is read from _f_i_l_e instead of from the com-
                      mand line.  Multiple --ff options are allowed.

       -vv _v_a_r_=_v_a_l_u_e   assigns _v_a_l_u_e to program variable _v_a_r.

       --             indicates the unambiguous end of options.

       The above options will be available with any Posix compatible implemen-
       tation  of  AWK,  and implementation specific options are prefaced with
       --WW.  mmaawwkk provides six:

       -WW version     mmaawwkk writes its version and copyright to stdout and com-
                      piled limits to stderr and exits 0.

       -WW dump        writes  an assembler like listing of the internal repre-
                      sentation of the program to stdout and exits 0 (on  suc-
                      cessful compilation).

       -WW interactive sets unbuffered writes to stdout and line buffered reads
                      from stdin.  Records from stdin are lines regardless  of
                      the value of RRSS.

       -WW exec _f_i_l_e   Program  text  is  read  from  _f_i_l_e and this is the last
                      option. Useful on systems that support  the  ##!!   "magic
                      number" convention for executable scripts.

       -WW sprintf=_n_u_m adjusts  the  size  of mmaawwkk''ss internal sprintf buffer to
                      _n_u_m bytes.  More than rare use of this option  indicates
                      mmaawwkk should be recompiled.

       -WW posix_space forces mmaawwkk not to consider '\n' to be space.

       The  short  forms  --WW[vdiesp] are recognized and on some systems --WWe is
       mandatory to avoid command line length limitations.

       mmaawwkk allows multiple --WW  options  to  be  combined  by  separating  the
       options with commas, e.g., -Wsprint=2000,posix.

TTHHEE AAWWKK LLAANNGGUUAAGGEE
   11.. PPrrooggrraamm ssttrruuccttuurree
       An  AWK  program is a sequence of _p_a_t_t_e_r_n _{_a_c_t_i_o_n_} pairs and user func-
       tion definitions.

       A pattern can be:
              BBEEGGIINN
              EENNDD
              expression
              expression , expression

       One, but not both, of _p_a_t_t_e_r_n _{_a_c_t_i_o_n_} can be omitted.   If _{_a_c_t_i_o_n_} is
       omitted  it is implicitly { print }.  If _p_a_t_t_e_r_n is omitted, then it is
       implicitly matched.  BBEEGGIINN and EENNDD patterns require an action.

       Statements are terminated by newlines, semi-colons or both.  Groups  of
       statements such as actions or loop bodies are blocked via { ... } as in
       C.  The last statement in a block doesn't  need  a  terminator.   Blank
       lines  have  no  meaning; an empty statement is terminated with a semi-
       colon. Long statements can be continued with a backslash, \.  A  state-
       ment  can  be broken without a backslash after a comma, left brace, &&,
       ||, ddoo, eellssee, the right parenthesis of an iiff, wwhhiillee or  ffoorr  statement,
       and  the  right parenthesis of a function definition.  A comment starts
       with # and extends to, but does not include the end of line.

       The following statements control program flow inside blocks.

              iiff ( _e_x_p_r ) _s_t_a_t_e_m_e_n_t

              iiff ( _e_x_p_r ) _s_t_a_t_e_m_e_n_t eellssee _s_t_a_t_e_m_e_n_t

              wwhhiillee ( _e_x_p_r ) _s_t_a_t_e_m_e_n_t

              ddoo _s_t_a_t_e_m_e_n_t wwhhiillee ( _e_x_p_r )

              ffoorr ( _o_p_t___e_x_p_r ; _o_p_t___e_x_p_r ; _o_p_t___e_x_p_r ) _s_t_a_t_e_m_e_n_t

              ffoorr ( _v_a_r iinn _a_r_r_a_y ) _s_t_a_t_e_m_e_n_t

              ccoonnttiinnuuee

              bbrreeaakk

   22.. DDaattaa ttyyppeess,, ccoonnvveerrssiioonn aanndd ccoommppaarriissoonn
       There are two basic data types, numeric and string.  Numeric  constants
       can  be  integer  like -2, decimal like 1.08, or in scientific notation
       like -1.1e4 or .28E-3.  All numbers are represented internally and  all
       computations  are  done  in floating point arithmetic.  So for example,
       the expression 0.2e2 == 20 is true and true is represented as 1.0.

       String constants are enclosed in double quotes.

                   "This is a string with a newline at the end.\n"

       Strings can be continued across a line by  escaping  (\)  the  newline.
       The following escape sequences are recognized.

            \\        \
            \"        "
            \a        alert, ascii 7
            \b        backspace, ascii 8
            \t        tab, ascii 9
            \n        newline, ascii 10
            \v        vertical tab, ascii 11
            \f        formfeed, ascii 12
            \r        carriage return, ascii 13
            \ddd      1, 2 or 3 octal digits for ascii ddd
            \xhh      1 or 2 hex digits for ascii  hh

       If  you  escape  any other character \c, you get \c, i.e., mmaawwkk ignores
       the escape.

       There are really three basic data types; the third is _n_u_m_b_e_r _a_n_d _s_t_r_i_n_g
       which  has  both  a  numeric value and a string value at the same time.
       User defined variables come into existence when  first  referenced  and
       are  initialized  to  _n_u_l_l, a number and string value which has numeric
       value 0 and string value "".  Non-trivial number and string typed  data
       come from input and are typically stored in fields.  (See section 4).

       The  type  of  an expression is determined by its context and automatic
       type conversion occurs if needed.  For example, to evaluate the  state-
       ments

            y = x + 2  ;  z = x  "hello"

       The  value  stored  in  variable  y will be typed numeric.  If x is not
       numeric, the value read from x is converted to  numeric  before  it  is
       added  to  2  and  stored in y.  The value stored in variable z will be
       typed string, and the value of x will be converted to string if  neces-
       sary  and  concatenated  with  "hello".  (Of course, the value and type
       stored in x is not changed by any conversions.)  A string expression is
       converted  to numeric using its longest numeric prefix as with _a_t_o_f(3).
       A numeric expression is converted to  string  by  replacing  _e_x_p_r  with
       sspprriinnttff((CCOONNVVFFMMTT,  _e_x_p_r),  unless  _e_x_p_r  can  be represented on the host
       machine as an exact integer  then  it  is  converted  to  sspprriinnttff("%d",
       _e_x_p_r).   SSpprriinnttff(()) is an AWK built-in that duplicates the functionality
       of _s_p_r_i_n_t_f(3), and CCOONNVVFFMMTT is a built-in  variable  used  for  internal
       conversion  from  number to string and initialized to "%.6g".  Explicit
       type conversions can be  forced,  _e_x_p_r  ""  is  string  and  _e_x_p_r+0  is
       numeric.

       To evaluate, _e_x_p_r1 rreell--oopp _e_x_p_r2, if both operands are numeric or number
       and string then the comparison is numeric; if both operands are  string
       the  comparison is string; if one operand is string, the non-string op-
       erand is converted  and  the  comparison  is  string.   The  result  is
       numeric, 1 or 0.

       In boolean contexts such as, iiff ( _e_x_p_r ) _s_t_a_t_e_m_e_n_t, a string expression
       evaluates true if and only if it is not the empty  string  "";  numeric
       values if and only if not numerically zero.

   33.. RReegguullaarr eexxpprreessssiioonnss
       In  the  AWK language, records, fields and strings are often tested for
       matching a _r_e_g_u_l_a_r _e_x_p_r_e_s_s_i_o_n.  Regular  expressions  are  enclosed  in
       slashes, and

            _e_x_p_r ~ /_r/

       is  an  AWK  expression  that evaluates to 1 if _e_x_p_r "matches" _r, which
       means a substring of _e_x_p_r is in the set of strings defined by _r.   With
       no  match  the  expression  evaluates  to  0; replacing ~ with the "not
       match" operator, !~ , reverses the meaning.  As  pattern-action pairs,

            /_r/ { _a_c_t_i_o_n }   and   $$00 ~ /_r/ { _a_c_t_i_o_n }

       are the same, and for each input record that matches _r, _a_c_t_i_o_n is  exe-
       cuted.   In  fact, /_r/ is an AWK expression that is equivalent to ($$00 ~
       /_r/) anywhere except when on the right side  of  a  match  operator  or
       passed  as  an  argument  to a built-in function that expects a regular
       expression argument.

       AWK uses extended regular expressions as with  _e_g_r_e_p(1).   The  regular
       expression  metacharacters, i.e., those with special meaning in regular
       expressions are

             ^ $ . [ ] | ( ) * + ?

       Regular expressions are built up from characters as follows:

              _c            matches any non-metacharacter _c.

              \_c           matches a character  defined  by  the  same  escape
                           sequences  used  in string constants or the literal
                           character _c if \_c is not an escape sequence.

              .            matches any character (including newline).

              ^            matches the front of a string.

              $            matches the back of a string.

              [c1c2c3...]  matches any character in the class c1c2c3... .   An
                           interval  of  characters  is denoted c1-c2 inside a
                           class [...].

              [^c1c2c3...] matches any character not in the class c1c2c3...

       Regular expressions are built up from other regular expressions as fol-
       lows:

              _r1_r2         matches  _r1  followed immediately by _r2 (concatena-
                           tion).

              _r1 | _r2      matches _r1 or _r2 (alternation).

              _r*           matches _r repeated zero or more times.

              _r+           matches _r repeated one or more times.

              _r?           matches _r zero or once.

              (_r)          matches _r, providing grouping.

       The increasing precedence of operators  is  alternation,  concatenation
       and unary (*, + or ?).

       For example,

            /^[_a-zA-Z][_a-zA-Z0-9]*$/  and
            /^[-+]?([0-9]+\.?|\.[0-9])[0-9]*([eE][-+]?[0-9]+)?$/

       are  matched by AWK identifiers and AWK numeric constants respectively.
       Note that . has to be escaped to be recognized as a decimal point,  and
       that metacharacters are not special inside character classes.

       Any expression can be used on the right hand side of the ~ or !~ opera-
       tors or passed to a built-in that expects  a  regular  expression.   If
       needed,  it  is  converted to string, and then interpreted as a regular
       expression.  For example,

            BEGIN { identifier = "[_a-zA-Z][_a-zA-Z0-9]*" }

            $0 ~ "^" identifier

       prints all lines that start with an AWK identifier.

       mmaawwkk recognizes the empty regular expression,  //,  which  matches  the
       empty  string and hence is matched by any string at the front, back and
       between every character.  For example,

            echo  abc | mawk { gsub(//, "X") ; print }
            XaXbXcX


   44.. RReeccoorrddss aanndd ffiieellddss
       Records are read in one at a time, and stored in the _f_i_e_l_d variable $$00.
       The  record  is split into _f_i_e_l_d_s which are stored in $$11, $$22, ..., $$NNFF.
       The built-in variable NNFF is set to the number of fields, and NNRR and FFNNRR
       are incremented by 1.  Fields above $$NNFF are set to "".

       Assignment to $$00 causes the fields and NNFF to be recomputed.  Assignment
       to NNFF or to a field causes $$00 to be reconstructed by concatenating  the
       $$ii''ss  separated  by OOFFSS.  Assignment to a field with index greater than
       NNFF, increases NNFF and causes $$00 to be reconstructed.

       Data input stored in fields is string,  unless  the  entire  field  has
       numeric form and then the type is number and string.  For example,

            echo 24 24E |
            mawk '{ print($1>100, $1>"100", $2>100, $2>"100") }'
            0 1 1 1

       $$00 and $$22 are string and $$11 is number and string.  The first comparison
       is numeric, the second is string, the third is string (100 is converted
       to "100"), and the last is string.

   55.. EExxpprreessssiioonnss aanndd ooppeerraattoorrss
       The expression syntax is similar to C.  Primary expressions are numeric
       constants, string constants, variables,  fields,  arrays  and  function
       calls.   The  identifier  for  a  variable,  array or function can be a
       sequence of letters, digits and underscores, that does not start with a
       digit.   Variables  are  not declared; they exist when first referenced
       and are initialized to _n_u_l_l.

       New expressions are composed with the following operators in  order  of
       increasing precedence.

              _a_s_s_i_g_n_m_e_n_t          =  +=  -=  *=  /=  %=  ^=
              _c_o_n_d_i_t_i_o_n_a_l         ?  :
              _l_o_g_i_c_a_l _o_r          ||
              _l_o_g_i_c_a_l _a_n_d         &&
              _a_r_r_a_y _m_e_m_b_e_r_s_h_i_p    iinn
              _m_a_t_c_h_i_n_g       ~   !~
              _r_e_l_a_t_i_o_n_a_l          <  >   <=  >=  ==  !=
              _c_o_n_c_a_t_e_n_a_t_i_o_n       (no explicit operator)
              _a_d_d _o_p_s             +  -
              _m_u_l _o_p_s             *  /  %
              _u_n_a_r_y               +  -
              _l_o_g_i_c_a_l _n_o_t         !
              _e_x_p_o_n_e_n_t_i_a_t_i_o_n      ^
              _i_n_c _a_n_d _d_e_c         ++ -- (both post and pre)
              _f_i_e_l_d               $

       Assignment, conditional and exponentiation associate right to left; the
       other operators associate left to right.  Any expression can be  paren-
       thesized.

   66.. AArrrraayyss
       Awk  provides  one-dimensional arrays.  Array elements are expressed as
       _a_r_r_a_y[_e_x_p_r].  _E_x_p_r is internally converted  to  string  type,  so,  for
       example,  A[1]  and A["1"] are the same element and the actual index is
       "1".  Arrays indexed by strings are called  associative  arrays.   Ini-
       tially  an  array  is  empty;  elements  exist when first accessed.  An
       expression, _e_x_p_r iinn _a_r_r_a_y evaluates to 1 if _a_r_r_a_y[_e_x_p_r] exists, else to
       0.

       There  is  a form of the ffoorr statement that loops over each index of an
       array.

            ffoorr ( _v_a_r iinn _a_r_r_a_y ) _s_t_a_t_e_m_e_n_t

       sets _v_a_r to each index of _a_r_r_a_y and executes _s_t_a_t_e_m_e_n_t.  The order that
       _v_a_r transverses the indices of _a_r_r_a_y is not defined.

       The  statement,  ddeelleettee  _a_r_r_a_y[_e_x_p_r],  causes _a_r_r_a_y[_e_x_p_r] not to exist.
       mmaawwkk supports an extension, ddeelleettee _a_r_r_a_y, which deletes all elements of
       _a_r_r_a_y.

       Multidimensional  arrays  are  synthesized with concatenation using the
       built-in  variable  SSUUBBSSEEPP.   _a_r_r_a_y[_e_x_p_r1,_e_x_p_r2]   is   equivalent   to
       _a_r_r_a_y[_e_x_p_r1 SSUUBBSSEEPP _e_x_p_r2].  Testing for a multidimensional element uses
       a parenthesized index, such as

            if ( (i, j) in A )  print A[i, j]


   77.. BBuuiillttiinn--vvaarriiaabblleess
       The following variables are built-in  and  initialized  before  program
       execution.

              AARRGGCC      number of command line arguments.

              AARRGGVV      array of command line arguments, 0..ARGC-1.

              CCOONNVVFFMMTT   format  for  internal conversion of numbers to string,
                        initially = "%.6g".

              EENNVVIIRROONN   array indexed by environment variables.   An  environ-
                        ment  string,  _v_a_r_=_v_a_l_u_e  is  stored as EENNVVIIRROONN[_v_a_r] =
                        _v_a_l_u_e.

              FFIILLEENNAAMMEE  name of the current input file.

              FFNNRR       current record number in FFIILLEENNAAMMEE.

              FFSS        splits records into fields as a regular expression.

              NNFF        number of fields in the current record.

              NNRR        current record number in the total input stream.

              OOFFMMTT      format for printing numbers; initially = "%.6g".

              OOFFSS       inserted between fields on output, initially = " ".

              OORRSS       terminates each record on output, initially = "\n".

              RRLLEENNGGTTHH   length set by the last call to the built-in  function,
                        mmaattcchh(()).

              RRSS        input record separator, initially = "\n".

              RRSSTTAARRTT    index set by the last call to mmaattcchh(()).

              SSUUBBSSEEPP    used  to  build multiple array subscripts, initially =
                        "\034".

   88.. BBuuiilltt--iinn ffuunnccttiioonnss
       String functions

              gsub(_r_,_s_,_t)  gsub(_r_,_s)
                     Global substitution, every match of regular expression  _r
                     in  variable  _t  is  replaced by string _s.  The number of
                     replacements is returned.  If _t is omitted, $$00  is  used.
                     An  &  in  the  replacement  string  _s is replaced by the
                     matched substring of _t.  \& and \\ put  literal & and  \,
                     respectively, in the replacement string.

              index(_s_,_t)
                     If  _t  is  a  substring  of  _s, then the position where _t
                     starts is returned, else 0 is returned.  The first  char-
                     acter of _s is in position 1.

              length(_s)
                     Returns the length of string _s.

              match(_s_,_r)
                     Returns  the  index of the first longest match of regular
                     expression _r in string _s.  Returns 0 if no match.   As  a
                     side  effect, RRSSTTAARRTT is set to the return value.  RRLLEENNGGTTHH
                     is set to the length of the match or -1 if no match.   If
                     the  empty  string is matched, RRLLEENNGGTTHH is set to 0, and 1
                     is returned if the match is at the front, and length(_s)+1
                     is returned if the match is at the back.

              split(_s_,_A_,_r)  split(_s_,_A)
                     String _s is split into fields by regular expression _r and
                     the fields are loaded into array _A.  The number of fields
                     is returned.  See section 11 below for more detail.  If _r
                     is omitted, FFSS is used.

              sprintf(_f_o_r_m_a_t_,_e_x_p_r_-_l_i_s_t)
                     Returns a string constructed from _e_x_p_r_-_l_i_s_t according  to
                     _f_o_r_m_a_t.  See the description of printf() below.

              sub(_r_,_s_,_t)  sub(_r_,_s)
                     Single  substitution,  same  as gsub() except at most one
                     substitution.

              substr(_s_,_i_,_n)  substr(_s_,_i)
                     Returns the substring of string _s, starting at  index  _i,
                     of  length _n.  If _n is omitted, the suffix of _s, starting
                     at _i is returned.

              tolower(_s)
                     Returns a copy of _s with all upper case  characters  con-
                     verted to lower case.

              toupper(_s)
                     Returns  a  copy of _s with all lower case characters con-
                     verted to upper case.

       Arithmetic functions

              atan2(_y_,_x)     Arctan of _y/_x between -pi and pi.

              cos(_x)         Cosine function, _x in radians.

              exp(_x)         Exponential function.

              int(_x)         Returns _x truncated towards zero.

              log(_x)         Natural logarithm.

              rand()         Returns a random number between zero and one.

              sin(_x)         Sine function, _x in radians.

              sqrt(_x)        Returns square root of _x.

              srand(_e_x_p_r)  srand()
                     Seeds the random number generator,  using  the  clock  if
                     _e_x_p_r  is  omitted,  and returns the value of the previous
                     seed.  mmaawwkk seeds the random number  generator  from  the
                     clock  at  startup  so  there  is  no  real  need to call
                     srand().  Srand(_e_x_p_r) is useful for repeating pseudo ran-
                     dom sequences.

   99.. IInnppuutt aanndd oouuttppuutt
       There are two output statements, pprriinntt and pprriinnttff.

              print  writes $$00  OORRSS to standard output.

              print _e_x_p_r1, _e_x_p_r2, ..., _e_x_p_rn
                     writes _e_x_p_r1 OOFFSS _e_x_p_r2 OOFFSS ... _e_x_p_rn OORRSS to standard out-
                     put.  Numeric expressions are converted  to  string  with
                     OOFFMMTT.

              printf _f_o_r_m_a_t_, _e_x_p_r_-_l_i_s_t
                     duplicates the printf C library function writing to stan-
                     dard output.  The complete ANSI C  format  specifications
                     are  recognized  with conversions %c, %d, %e, %E, %f, %g,
                     %G, %i, %o, %s, %u, %x, %X and %%, and conversion  quali-
                     fiers h and l.

       The  argument  list  to  print  or printf can optionally be enclosed in
       parentheses.  Print formats numbers using OOFFMMTT or "%d" for exact  inte-
       gers.   "%c"  with  a  numeric  argument prints the corresponding 8 bit
       character, with a string argument it prints the first character of  the
       string.   The output of print and printf can be redirected to a file or
       command by appending > _f_i_l_e, >> _f_i_l_e or | _c_o_m_m_a_n_d to  the  end  of  the
       print  statement.   Redirection opens _f_i_l_e or _c_o_m_m_a_n_d only once, subse-
       quent redirections append to the already open stream.   By  convention,
       mmaawwkk  associates  the  filename  "/dev/stderr" with stderr which allows
       print and printf to be redirected to stderr.  mmaawwkk also associates  "-"
       and  "/dev/stdout"  with stdin and stdout which allows these streams to
       be passed to functions.

       The input function ggeettlliinnee has the following variations.

              getline
                     reads into $$00, updates the fields, NNFF, NNRR and FFNNRR.

              getline < _f_i_l_e
                     reads into $$00 from _f_i_l_e, updates the fields and NNFF.

              getline _v_a_r
                     reads the next record into _v_a_r, updates NNRR and FFNNRR.

              getline _v_a_r < _f_i_l_e
                     reads the next record of _f_i_l_e into _v_a_r.

               _c_o_m_m_a_n_d | getline
                     pipes a record from  _c_o_m_m_a_n_d  into  $$00  and  updates  the
                     fields and NNFF.

               _c_o_m_m_a_n_d | getline _v_a_r
                     pipes a record from _c_o_m_m_a_n_d into _v_a_r.

       Getline returns 0 on end-of-file, -1 on error, otherwise 1.

       Commands on the end of pipes are executed by /bin/sh.

       The  function cclloossee(_e_x_p_r) closes the file or pipe associated with _e_x_p_r.
       Close returns 0 if _e_x_p_r is an open file, the exit status if _e_x_p_r  is  a
       piped  command,  and  -1  otherwise.  Close is used to reread a file or
       command, make sure the other end of an output pipe is finished or  con-
       serve file resources.

       The  function  fffflluusshh(_e_x_p_r)  flushes the output file or pipe associated
       with _e_x_p_r.  Fflush returns 0 if _e_x_p_r is an open output stream else  -1.
       Fflush  without an argument flushes stdout.  Fflush with an empty argu-
       ment ("") flushes all open output.

       The function ssyysstteemm(_e_x_p_r) uses /bin/sh to execute _e_x_p_r and returns  the
       exit status of the command _e_x_p_r.  Changes made to the EENNVVIIRROONN array are
       not passed to commands executed with ssyysstteemm or pipes.

   1100.. UUsseerr ddeeffiinneedd ffuunnccttiioonnss
       The syntax for a user defined function is

            ffuunnccttiioonn name( _a_r_g_s ) { _s_t_a_t_e_m_e_n_t_s }

       The function body can contain a return statement

            rreettuurrnn _o_p_t___e_x_p_r

       A return statement is not required.  Function calls may  be  nested  or
       recursive.   Functions  are  passed  expressions by value and arrays by
       reference.  Extra arguments serve as local variables and  are  initial-
       ized  to  _n_u_l_l.  For example, csplit(_s_,_A) puts each character of _s into
       array _A and returns the length of _s.

            function csplit(s, A,    n, i)
            {
              n = length(s)
              for( i = 1 ; i <= n ; i++ ) A[i] = substr(s, i, 1)
              return n
            }

       Putting extra space between passed arguments  and  local  variables  is
       conventional.  Functions can be referenced before they are defined, but
       the function name and the '(' of the arguments must touch to avoid con-
       fusion with concatenation.

   1111.. SSpplliittttiinngg ssttrriinnggss,, rreeccoorrddss aanndd ffiilleess
       Awk  programs  use the same algorithm to split strings into arrays with
       split(), and records into fields on FFSS.  mmaawwkk uses essentially the same
       algorithm to split files into records on RRSS.

       Split(_e_x_p_r_,_A_,_s_e_p) works as follows:

              (1)    If  _s_e_p  is omitted, it is replaced by FFSS.  _S_e_p can be an
                     expression or regular expression.  If it is an expression
                     of non-string type, it is converted to string.

              (2)    If  _s_e_p  =  " " (a single space), then <SPACE> is trimmed
                     from the front and back of _e_x_p_r, and _s_e_p becomes <SPACE>.
                     mmaawwkk   defines   <SPACE>   as   the   regular  expression
                     /[ \t\n]+/.   Otherwise  _s_e_p  is  treated  as  a  regular
                     expression, except that meta-characters are ignored for a
                     string of length 1, e.g., split(x, A, "*")  and  split(x,
                     A, /\*/) are the same.

              (3)    If  _e_x_p_r  is  not  string, it is converted to string.  If
                     _e_x_p_r is then the empty string "", split() returns 0 and _A
                     is  set  empty.  Otherwise, all non-overlapping, non-null
                     and longest matches of _s_e_p in _e_x_p_r,  separate  _e_x_p_r  into
                     fields which are loaded into _A.  The fields are placed in
                     A[1], A[2], ..., A[n] and split() returns n,  the  number
                     of  fields which is the number of matches plus one.  Data
                     placed in _A  that  looks  numeric  is  typed  number  and
                     string.

       Splitting  records  into  fields  works  the same except the pieces are
       loaded into $$11, $$22,..., $$NNFF.  If $$00 is empty, NNFF is set to 0 and all $$ii
       to "".

       mmaawwkk  splits  files  into  records  by the same algorithm, but with the
       slight difference that RRSS is really a terminator instead of  a  separa-
       tor.  (OORRSS is really a terminator too).

              E.g.,  if FFSS = ":+" and $$00 = "a::b:" , then NNFF = 3 and $$11 = "a",
              $$22 = "b" and $$33 = "", but if "a::b:" is the contents of an input
              file and RRSS = ":+", then there are two records "a" and "b".

       RRSS = " " is not special.

       If  FFSS  =  "",  then mmaawwkk breaks the record into individual characters,
       and, similarly, split(_s_,_A_,"") places the  individual  characters  of  _s
       into _A.

   1122.. MMuullttii--lliinnee rreeccoorrddss
       Since  mmaawwkk  interprets  RRSS as a regular expression, multi-line records
       are easy.  Setting RRSS = "\n\n+", makes one or more blank lines separate
       records.  If FFSS = " " (the default), then single newlines, by the rules
       for <SPACE> above, become space and single newlines are  field  separa-
       tors.

              For  example,  if  a file is "a b\nc\n\n", RRSS = "\n\n+" and FFSS =
              " ", then there is one record "a b\nc" with  three  fields  "a",
              "b"  and  "c".   Changing  FFSS = "\n", gives two fields "a b" and
              "c"; changing FFSS = "", gives one field identical to the record.

       If you want lines with spaces or tabs to be considered blank, set RRSS  =
       "\n([ \t]*\n)+".   For  compatibility  with other awks, setting RRSS = ""
       has the same effect as if blank lines are stripped from the  front  and
       back  of  files  and  then  records  are determined as if RRSS = "\n\n+".
       Posix requires that "\n" always separates records when RRSS = ""  regard-
       less  of  the  value  of  FFSS.   mmaawwkk  does not support this convention,
       because defining "\n" as <SPACE> makes it unnecessary.

       Most of the time when you change RRSS for multi-line  records,  you  will
       also want to change OORRSS to "\n\n" so the record spacing is preserved on
       output.

   1133.. PPrrooggrraamm eexxeeccuuttiioonn
       This section describes the order of program execution.  First  AARRGGCC  is
       set  to the total number of command line arguments passed to the execu-
       tion phase of the program.  AARRGGVV[[00]] is set the name of the  AWK  inter-
       preter  and  AARRGGVV[[11]] ...  AARRGGVV[[AARRGGCC--11]] holds the remaining command line
       arguments exclusive of options and program source.  For example with

            mawk  -f  prog  v=1  A  t=hello  B

       AARRGGCC = 5 with AARRGGVV[[00]] = "mawk", AARRGGVV[[11]] = "v=1", AARRGGVV[[22]] = "A", AARRGGVV[[33]]
       = "t=hello" and AARRGGVV[[44]] = "B".

       Next,  each  BBEEGGIINN block is executed in order.  If the program consists
       entirely of BBEEGGIINN blocks, then  execution  terminates,  else  an  input
       stream  is opened and execution continues.  If AARRGGCC equals 1, the input
       stream is set to stdin, else  the command line  arguments  AARRGGVV[[11]]  ...
       AARRGGVV[[AARRGGCC--11]] are examined for a file argument.

       The  command  line  arguments  divide  into three sets: file arguments,
       assignment arguments and empty strings "".  An assignment has the  form
       _v_a_r=_s_t_r_i_n_g.   When  an AARRGGVV[[ii]] is examined as a possible file argument,
       if it is empty it is skipped; if it  is  an  assignment  argument,  the
       assignment  to  _v_a_r  takes place and ii skips to the next argument; else
       AARRGGVV[[ii]] is opened for input.  If it fails to open, execution terminates
       with exit code 2.  If no command line argument is a file argument, then
       input comes from stdin.  Getline in a BBEEGGIINN action opens input.  "-" as
       a file argument denotes stdin.

       Once  an input stream is open, each input record is tested against each
       _p_a_t_t_e_r_n, and if it matches, the  associated  _a_c_t_i_o_n  is  executed.   An
       expression  pattern  matches if it is boolean true (see the end of sec-
       tion 2).  A BBEEGGIINN pattern matches before any input has been  read,  and
       an EENNDD pattern matches after all input has been read.  A range pattern,
       _e_x_p_r1,_e_x_p_r2 , matches every record between the match of _e_x_p_r1  and  the
       match _e_x_p_r2 inclusively.

       When end of file occurs on the input stream, the remaining command line
       arguments are examined for a file argument, and if there is one  it  is
       opened,  else the EENNDD _p_a_t_t_e_r_n is considered matched and all EENNDD _a_c_t_i_o_n_s
       are executed.

       In the example, the assignment v=1 takes place after the BBEEGGIINN  _a_c_t_i_o_n_s
       are  executed,  and  the  data  placed in v is typed number and string.
       Input is then read from file A.  On end of file A,  t  is  set  to  the
       string  "hello",  and B is opened for input.  On end of file B, the EENNDD
       _a_c_t_i_o_n_s are executed.

       Program flow at the _p_a_t_t_e_r_n _{_a_c_t_i_o_n_} level can be changed with the

            nneexxtt
            eexxiitt  _o_p_t___e_x_p_r

       statements.  A nneexxtt statement causes the next input record to  be  read
       and  pattern testing to restart with the first _p_a_t_t_e_r_n _{_a_c_t_i_o_n_} pair in
       the program.  An eexxiitt statement causes immediate execution of  the  EENNDD
       actions  or program termination if there are none or if the eexxiitt occurs
       in an EENNDD action.  The _o_p_t___e_x_p_r sets the  exit  value  of  the  program
       unless overridden by a later eexxiitt or subsequent error.

EEXXAAMMPPLLEESS
       1. emulate cat.

            { print }

       2. emulate wc.

            { chars += length($0) + 1  # add one for the \n
              words += NF
            }

            END{ print NR, words, chars }

       3. count the number of unique "real words".

            BEGIN { FS = "[^A-Za-z]+" }

            { for(i = 1 ; i <= NF ; i++)  word[$i] = "" }

            END { delete word[""]
                  for ( i in word )  cnt++
                  print cnt
            }

       4. sum the second field of every record based on the first field.

            $1 ~ /credit|gain/ { sum += $2 }
            $1 ~ /debit|loss/  { sum -= $2 }

            END { print sum }

       5. sort a file, comparing as string

            { line[NR] = $0 "" }  # make sure of comparison type
                            # in case some lines look numeric

            END {  isort(line, NR)
              for(i = 1 ; i <= NR ; i++) print line[i]
            }

            #insertion sort of A[1..n]
            function isort( A, n,    i, j, hold)
            {
              for( i = 2 ; i <= n ; i++)
              {
                hold = A[j = i]
                while ( A[j-1] > hold )
                { j-- ; A[j+1] = A[j] }
                A[j] = hold
              }
              # sentinel A[0] = "" will be created if needed
            }


CCOOMMPPAATTIIBBIILLIITTYY IISSSSUUEESS
       The  Posix  1003.2(draft 11.3) definition of the AWK language is AWK as
       described in the AWK book with a few extensions that appeared  in  Sys-
       temVR4 nawk. The extensions are:

              New functions: toupper() and tolower().

              New variables: ENVIRON[] and CONVFMT.

              ANSI C conversion specifications for printf() and sprintf().

              New  command  options:   -v  var=value,  multiple -f options and
              implementation options as arguments to -W.

              For systems (MS-DOS or Windows) which provide  a  _s_e_t_m_o_d_e  func-
              tion,  an  environment variable MAWKBINMODE and a built-in vari-
              able BINMODE.  The bits of the BINMODE value tell  _m_a_w_k  how  to
              modify the RRSS and OORRSS variables:

                 0  set  standard input to binary mode, and if BIT-2 is unset,
                    set RRSS to "\r\n" (CR/LF) rather than "\n" (LF).

                 1  set standard output to binary mode, and if BIT-2 is unset,
                    set OORRSS to "\r\n" (CR/LF) rather than "\n" (LF).

                 2  suppress  the assignment to RRSS and OORRSS of CR/LF, making it
                    possible to run scripts  and  generate  output  compatible
                    with Unix line-endings.

       Posix  AWK is oriented to operate on files a line at a time.  RRSS can be
       changed from "\n" to another single character, but it is hard  to  find
       any  use for this -- there are no examples in the AWK book.  By conven-
       tion, RRSS = "", makes one or more blank lines separate records, allowing
       multi-line  records.   When  RRSS  = "", "\n" is always a field separator
       regardless of the value in FFSS.

       mmaawwkk, on the other hand, allows RRSS to be a  regular  expression.   When
       "\n"  appears  in records, it is treated as space, and FFSS always deter-
       mines fields.

       Removing the line at a time paradigm can make some programs simpler and
       can  often  improve  performance.   For example, redoing example 3 from
       above,

            BEGIN { RS = "[^A-Za-z]+" }

            { word[ $0 ] = "" }

            END { delete  word[ "" ]
              for( i in word )  cnt++
              print cnt
            }

       counts the number of unique words by making each  word  a  record.   On
       moderate  size  files, mmaawwkk executes twice as fast, because of the sim-
       plified inner loop.

       The following program replaces each comment by a single space  in  a  C
       program file,

            BEGIN {
              RS = "/\*([^*]|\*+[^/*])*\*+/"
                 # comment is record separator
              ORS = " "
              getline  hold
              }

              { print hold ; hold = $0 }

              END { printf "%s" , hold }

       Buffering  one  record  is  needed to avoid terminating the last record
       with a space.

       With mmaawwkk, the following are all equivalent,

            x ~ /a\+b/    x ~ "a\+b"     x ~ "a\\+b"

       The strings get scanned twice, once  as  string  and  once  as  regular
       expression.   On the string scan, mmaawwkk ignores the escape on non-escape
       characters while the AWK book advocates _\_c be  recognized  as  _c  which
       necessitates  the double escaping of meta-characters in strings.  Posix
       explicitly declines to define the behavior which passively forces  pro-
       grams  that  must  run under a variety of awks to use the more portable
       but less readable, double escape.

       Posix AWK does not  recognize  "/dev/std{out,err}"  or  \x  hex  escape
       sequences  in strings.  Unlike ANSI C, mmaawwkk limits the number of digits
       that follows \x to two as the current implementation  only  supports  8
       bit  characters.  The built-in fffflluusshh first appeared in a recent (1993)
       AT&T awk released to netlib, and is not part  of  the  posix  standard.
       Aggregate deletion with ddeelleettee _a_r_r_a_y is not part of the posix standard.

       Posix explicitly leaves the behavior of FFSS = "" undefined, and mentions
       splitting the record into characters as a possible interpretation,  but
       currently this use is not portable across implementations.

       Finally,  here  is  how mmaawwkk handles exceptional cases not discussed in
       the AWK book or the Posix draft.  It is unsafe  to  assume  consistency
       across awks and safe to skip to the next section.

              substr(s,  i, n) returns the characters of s in the intersection
              of the closed interval [1, length(s)] and the half-open interval
              [i,  i+n).  When this intersection is empty, the empty string is
              returned; so substr("ABC", 1, 0) = "" and substr("ABC", -4, 6) =
              "A".

              Every  string,  including  the  empty  string, matches the empty
              string at the front so, s ~ // and s ~ "", are always  1  as  is
              match(s, //) and match(s, "").  The last two set RRLLEENNGGTTHH to 0.

              index(s,  t)  is always the same as match(s, t1) where t1 is the
              same as t with metacharacters escaped.  Hence  consistency  with
              match  requires  that  index(s,  "") always returns 1.  Also the
              condition, index(s,t) != 0 if and only t is a  substring  of  s,
              requires index("","") = 1.

              If  getline  encounters  end  of  file,  getline var, leaves var
              unchanged.  Similarly, on entry to  the  EENNDD  actions,  $$00,  the
              fields and NNFF have their value unaltered from the last record.

SSEEEE AALLSSOO
       _e_g_r_e_p(1)

       Aho,  Kernighan  and Weinberger, _T_h_e _A_W_K _P_r_o_g_r_a_m_m_i_n_g _L_a_n_g_u_a_g_e, Addison-
       Wesley Publishing, 1988, (the AWK book), defines the language,  opening
       with  a  tutorial and advancing to many interesting programs that delve
       into issues of software design and analysis relevant to programming  in
       any language.

       _T_h_e  _G_A_W_K _M_a_n_u_a_l, The Free Software Foundation, 1991, is a tutorial and
       language reference that does not attempt the depth of the AWK book  and
       assumes  the  reader  may  be  a novice programmer.  The section on AWK
       arrays is excellent.  It also discusses Posix requirements for AWK.

BBUUGGSS
       mmaawwkk implements printf() and sprintf() using the C  library  functions,
       printf  and  sprintf,  so  full  ANSI  compatibility requires an ANSI C
       library.  In practice this means the h conversion qualifier may not  be
       available.   Also  mmaawwkk inherits any bugs or limitations of the library
       functions.

       Implementors of the AWK language have shown a consistent lack of imagi-
       nation when naming their programs.

AAUUTTHHOORR
       Mike Brennan (brennan@whidbey.com).
       Thomas E. Dickey <dickey@invisible-island.net>.



                                 USER COMMANDS                         MAWK(1)
