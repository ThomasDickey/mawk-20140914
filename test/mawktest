#!/bin/sh
# $MawkId: mawktest,v 1.19 2010/01/27 20:15:52 Jonathan.Nieder Exp $

# This is a simple test that a new made mawk seems to
# be working OK.
# It's certainly not exhaustive, but the last two tests in
# particular use most features.
#
# It needs to be run from  mawk/test
# and mawk needs to be in mawk/test or in PATH

PROG=mawk

MAWKBINMODE=7
export MAWKBINMODE

if test $# != 0 ; then
SRC=$1
else
SRC=..
fi

dat=mawktest.dat
nulldat=mawknull.dat

STDOUT=${TMPDIR-/tmp}/mawktest$$

ulimit -v 25000
trap 'echo mawk_test failed ; rm -f $STDOUT ; exit 1'  0

PATH=.:$PATH

# find out which mawk we're testing
$PROG -W version

NULLS=`$PROG -W version 2>&1 |fgrep 'internal regex' 2>/dev/null`
#################################
echo
echo testing input and field splitting

LC_ALL=C $PROG -f wc.awk $dat | cmp -s - wc-awk.out || exit
LC_ALL=C $PROG -f null-rs.awk null-rs.dat | cmp -s - null-rs.out || exit

LC_ALL=C $PROG -F '(a?)*b' -f wc.awk $dat > $STDOUT
LC_ALL=C $PROG -F 'a*b' -f wc.awk $dat | cmp -s - $STDOUT || exit

LC_ALL=C $PROG -F '(a?)+b' -f wc.awk $dat > $STDOUT
LC_ALL=C $PROG -F 'a*b' -f wc.awk $dat | cmp -s - $STDOUT || exit

LC_ALL=C $PROG -F '[^^]' -f wc.awk $dat > $STDOUT
LC_ALL=C $PROG -F '(.)' -f wc.awk $dat | cmp -s - $STDOUT || exit

LC_ALL=C $PROG -F '[^]]' -f wc.awk $dat > $STDOUT
LC_ALL=C $PROG -F '[[#a-zA-Z0-9/*!=<>+,;.&_%(){}" -]' -f wc.awk $dat |
	cmp -s - $STDOUT || exit

LC_ALL=C $PROG -F '[a[]' -f wc.awk $dat > $STDOUT
LC_ALL=C $PROG -F '[[a]' -f wc.awk $dat | cmp -s - $STDOUT || exit

LC_ALL=C $PROG -F '(])' -f wc.awk $dat > $STDOUT
LC_ALL=C $PROG -F '[]]' -f wc.awk $dat | cmp -s - $STDOUT || exit

if test -n "$NULLS" ; then
	LC_ALL=C $PROG -F '\000'    -f nulls0.awk $nulldat > $STDOUT
	LC_ALL=C $PROG -F '[\000 ]' -f nulls0.awk $nulldat >> $STDOUT
	cmp -s  nulls.out $STDOUT || exit
	echo "... $PROG supports matches with NUL bytes"
fi

echo input and field splitting OK
#####################################

echo
echo testing regular expression matching
LC_ALL=C $PROG -f reg0.awk $dat > $STDOUT
LC_ALL=C $PROG -f reg1.awk $dat >> $STDOUT
LC_ALL=C $PROG -f reg2.awk $dat >> $STDOUT
LC_ALL=C $PROG -f reg4.awk $dat >> $STDOUT
LC_ALL=C $PROG -f reg5.awk $dat >> $STDOUT
LC_ALL=C $PROG -f reg6.awk $dat >> $STDOUT

cmp -s  reg-awk.out $STDOUT || exit

# 640 backslashes
backslashes='\\\\\\\\\\'
backslashes="$backslashes$backslashes$backslashes$backslashes"
backslashes="$backslashes$backslashes$backslashes$backslashes"
backslashes="$backslashes$backslashes$backslashes$backslashes"
backslashes="$backslashes$backslashes$backslashes$backslashes"
( set +e; LC_ALL=C $PROG "/a$backslashes/" $dat; test $? -eq 2 ) || exit

LC_ALL=C $PROG '/^[^^]*$/' $dat > $STDOUT
cmp -s $dat $STDOUT || exit

LC_ALL=C $PROG '!/^[^]]*$/' $dat > $STDOUT
LC_ALL=C $PROG '/]/' $dat | cmp -s - $STDOUT || exit

LC_ALL=C $PROG '/[a[]/' $dat > $STDOUT
LC_ALL=C $PROG '/[[a]/' $dat | cmp -s - $STDOUT || exit

LC_ALL=C $PROG '/]/' $dat > $STDOUT
LC_ALL=C $PROG '/[]]/' $dat | cmp -s - $STDOUT || exit

echo regular expression matching OK
#######################################

echo
if [ -c /dev/full ]; then
    echo testing checking for write errors
    # Check for write errors noticed when closing the file
    LC_ALL=C $PROG '{print}' <full-awk.dat >/dev/full 2>/dev/null && exit
    # Check for write errors noticed on writing
    # The file has to be bigger than the buffer size of the libc
    LC_ALL=C $PROG '{print}' <$SRC/scan.c >/dev/full 2>/dev/null && exit

    echo checking for write errors OK
else
    echo "No /dev/full - check for write errors skipped"
fi

#######################################

echo
echo testing arrays and flow of control

LC_ALL=C $PROG -f wfrq0.awk $dat | cmp -s - wfrq-awk.out || exit

echo array test OK
#################################

echo
echo testing function calls and general stress test

LC_ALL=C $PROG -f $SRC/examples/decl.awk $dat | cmp -s - decl-awk.out || exit

echo general stress test passed


echo
echo  tested $PROG seems OK

trap 0
rm -f $STDOUT
exit 0
